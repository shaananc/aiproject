Mitchell Brunton - mbrunton
Shaanan Cohney   - sncohney

Overall time complexity (overestimate):
O(n^2 * 8^(n^2/4))

For part A of this project, we decided to implement our own, separate
ideas for solving the problem of counting the number of legal place/
jump moves for a game of Jumper. The reasons for this were two-fold:
firstly, having two different programs which produced the same
output for a variety of inputs would increase our confidence that our
solutions were correct, and secondly, we both had different ideas as
to how to structure our project, and having two quite separate
implementations would allow us to explore the benefits/pitfalls of each,
both in terms of time/space efficiency and code readability.

-- Mitchell's Code --
The general structure of Mitchell's code is as follows. A Gameboard
object contains an array of Cell objects, each of which as a STATE
enum set to one of four values (E, B, W, X).
The MoveCounter class creates objects which count the number of legal
moves for a given Gameboard. MoveCounter's countPlaceMoves method
scans through the cells of a Gameboard object, and returns the
number of empty cells, for a time complexity of O(n^2). MoveCounter's
countJumpMoves method scans through the Gameboard's cells, and for
each cell of state 'player', adds the result of the recursive
countJumpMovesFromPos method to a running tally. countJumpMovesFromPos
takes a Gameboard, and a Pos as arguments. It first creates an
ArrayList of NeighbourPairs, which holds (neighbour, neighbour's neighbour)
pairs, such that a piece situated on the current position might jump over
a neighbour onto the neighbour's neighbour.
For example, if the following Gameboard was passed to countJumpMovesFromPos
with position '*':

* 2 3
4 5 6
7 8 9

the resulting NeighbourPairs would be (2, 3), (5, 9), and (4, 7).
For each NeighbourPair, if neighbour is occupied by a piece, and neighbour's
neighbour is empty, the corresponding single jump move is made on a child board,
and (1 + countJumpMovesFromPos(child board, neighbour's neighbour's pos)) is
added to a running tally.

The worst-case complexity of countJumpMovesFromPos is difficult to state
precisely, however an overestimate is as follows:
Each countJumpMovesFromPos can make a maximum of 8 more calls to 
countJumpMovesFromPos, and a single path of recursive calls could not exceed
the maximum depth of ( n/2 )^2 - 1, which is obtained by considering that each
jump move moves exactly 2 squares, which means that a compound jump can visit
at most n/2 squares on half of the rows, and 0 squares on the other half,
minus 1 for the starting square. 
So the tree of recursive function calls has a maximum branching 
factor of 8, and a maximum depth of of ( n/2 )^2 - 1, and because each call
to countJumpMovesFromPos does a constant amount of work, this leads to a complexity
of O( 8^(n^2/4) ). Thus the complexity of countJumpMoves countMoves algorithm
is O(n^2 * 8^(n^2/4)), as is the complexity of the countMoves function, since
O(n^2 * 8^(n^2/4) + n^2) = O(n^2 * 8^(n^2/4)). In practice, this will be much
lower, as very few pieces will ever be able to make 8 jumps from a given
position, and the average depth of compound jumps will be significantly
lower than the theoretical maximum.


-- Shaanan's code --
Shaanan's code uses BitSets to try to minimise the amount of memory that the
board representation consumes.
Per square, it takes 2 bits to represent all 4 combinations, leading to a board state
that takes 2n^2+17 bits of memory including an integer boardsize and boolean turn variable.
A move is currently suboptimal, requiring 48 bits of memory, three 16 bit integers,
representing (x,y) and the 'jump' status of a given move. As a result of the bitwise
representation, a good number of helper function were written to test the state of a given
square. This makes the code fairly readable as the method names are quite descriptive.
Currently, executing a move returns a new GameBoard object, and one might assume this would be
the largest source of memory usage. However, on using the profiler, it seems that the
Move objects take even more space given that there are O(n^2) of them for each board state.
Move objects are generated when calculating the number of jumps to be made in order to count
the number of sub-compound-jumps via a modified version of DFS. The analysis follows as above,
given that the idea of the algorithms is near identical, varying only in implementation.


-- Comparison --
The complexity of any algorithm which counts the number of legal jump moves
will be dominated in the search for compound jumps. As it happened, we both
implemented a similar, recursive definition for solving this problem. We ran
a series of time trials in which each implementation was timed in counting 
the number of moves for a number of random board configurations, ranging from
200 boards to 1000 boards. To our surprise, both programs took almost exactly
the same amount of time to complete all tasks. For this assessment, we chose
to submit Mitchell's implementation.


